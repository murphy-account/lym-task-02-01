1 函数式编程的优点
可以抛弃this
可以在打包过程中利用tree shaking过滤无用代码
方便测试和并行处理
第三方库比如lodash underscore ramda
2 常用的编程范式
面向对象编程：把事物抽象成类和对象，通过封装，继承和多态演示事物间的联系。
    对事物进行抽象
面向过程编程：按照过程先后
函数式编程：对运算过程进行抽象，用来描述数据（函数）之间的映射。这个函数并不是指程序中的函数或者方法，而是一种映射关系 
3  理解函数是一等公民
I  函数是js中的一种对象
II 对象（函数）可以作为参数传入一个函数中
III对象（函数）可以作为一个函数的返回值
IV 可以给一个变量赋值一个对象（函数）
4  高阶函数（手写一个foreach和一个filter功能的函数）
console.log("手写一个filter功能的函数");
function filter(array,op){
    let results=[]
    for(let i = 0 ;i<array.length;i++){
        if(op(array[i] )){
             results.push(array[i])
        }
        
    }
    return results 
}
let arr=[1,2,3,5,4,8,9]
let a = filter(arr,function(item){
    return item %2==0
   
})
console.log(a);
5 模拟lodash中的once函数，即不管执行几次操作，最后这个操作只执行一次

function once(fn){
    let done = false
    return function(){
        
        if(!done){
            done = true
            
           return  fn.apply(this,arguments)
        }
    }
}
let fn = once(function(a){
    console.log("a");
    
})
fn(5)
fn(5)
fn(5)
fn(5)
fn(5)
6 使用高阶函数的意义
对运算过程进行抽象，屏蔽细节，只需要关注我们的目标
高阶函数就是用来抽象通用的问题
我的理解：当你解决一个问题A，你把解决这个问题A的方法封装成一个函数，每次需要解决问题A的时候就调用这个函数，这样实现了方法的复用，并且把解决A的方法抽离出去，会使代码更加简洁明了。

7 模拟map,every,some函数
①map
const map=(array,fn)=>{
    let results=[]
    for(let value of array){//遍历数组的每一个元素
        results.push(fn(value))
    }
    return results
}
let arr = [1,2,3,4,5,6,7]
arr = map(arr,v=>v*v)
console.log(...arr);
② every

③ some

8 
闭包的概念：函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包
闭包的作用：可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的其他成员。
保存变量和变量存在的环境让他不要销毁。
闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能被释放，因此内部函数依然可以访问到外部函数的成员。
9 纯函数
相同的输入永远会得到相同的输出

10 纯函数的好处
模拟一个memoize函数
纯函数让测试更方便
在多线程环境下并行操作共享的内存数据很可能会出现意外情况
纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数Web Worker

11 函数柯里化
当一个函数有多个参数的时候先传递一部分参数调用它 


12 lodash中的curry函数

13 柯里化实现原理
const _ = require('lodash')



14 函数组合
简单说就是合并几个函数变成一个函数


14 lodash中的组合函数使用
flow()  //从左往右运行
flowRight() //从右往左运行
15 数组的reduce()方法
对数组的每一个元素执行一个我们提供的函数，并汇总成单个结果
16 模拟lodash中的flowRight

17  用trace函数对组合函数进行调试


18 lodash中的fp模块
fp就是   对函数式编程友好的方法
原则是自动柯里化，函数优先，数据放后面

19 lodash/fp和lodash中的map函数的区别以及解决办法

20 point free（简单说就是函数组合）
我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只需要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。
1 不需要指明处理的数据
2 只需要合成运算过程
3 需要定义一些辅助的基本运算函数

21 point free案例

22 Functor  函子
容器：包含值和值的变形关系（函数）
函子：一个特殊容器，通过一个普通对象来实现，该对象有map方法，

没看懂

23

24  MayBe 函子
当传入函子的值可能是空值的情况时可以使用MayBe函子来处理


如果在链式调用的时候传入的值为null ,那么MayBe函子不会报错，但是找不到是哪一步调用出了问题，所以更优解在下一节Either函子

25 Either函子
类似于if 和Else

26 IO函子




27  函数式编程库folktale中的task函子的使用
28 pointed函子： 实现了of静态方法的函子

of方法是为了避免使用new来创建对象，更深层的含义是of方法用来把值放到上下文Context（把值放到容器中使用map来处理值）

29 IO函子的问题
30 Monad  单子   是变扁的Pointed函子
一个函子如果具有join和of两个方法并遵守一些定律就是一个Monad

1 内存管理
内存：由可读写单元组成，表示一片操作空间
管理：人为的去操作一片空间的申请，使用和释放
内存管理：开发者主动申请空间，使用空间，释放空间
管理流程：申请-使用-释放

申请：
let obj = {}
使用
obj.name = 'lg'
释放：
obj = null 

2 垃圾回收
对象不再被引用时是垃圾
对象不能从根上访问到时是垃圾
可达对象：可以访问到的对象就是可达对象（引用，作用域链）
标准是从根上出发是否能够被找到
根就是全局变量对象，也就是全局执行上下文

3 GC算法
1 GC是垃圾回收机制的简写
GC可以找到内存中的垃圾并释放和回收空间
2 什么样的东西作为垃圾看待
程序中不再需要使用对象

3 GC算法就是在查找垃圾释放空间/回收空间的时候查找和回收所遵循的规则。
4 常见的GC算法
引用计数：设置引用数，判断当前引用数是否为0
  	  规则：  引用关系改变时修改引用数字，引用数组为0时立即回收
   优点：  发现垃圾时立即回收，最大限度减少程序暂停，减少程序卡顿时间。
   缺点：  无法回收循环引用的对象，时间开销大 
                   

如图这种函数就无法清除掉Obj1和obj2 











标记清除:
  分成标记和清除，
遍历对象找到所有可达对象，然后清除掉标记和所有没被标记的可达对象
释放的空间放到空闲列表中，方便后续的申请使用
优点：解决循环引用的对象不能回收的问题
缺点：释放的空间可能不连续，导致空间碎片化，浪费空间，不会立即回收垃圾对象
标记整理：
   是标记清除的增强
  先标记，清除的时候会先整理，移动对象的位置，然后再清除
//分代回收

5 V8引擎  js执行引擎
特征：采用即时编译，V8内存设置上限  64位，1.5G内存，32位，800M内存。
6 V8垃圾回收策略
采用分代回收的思想
内存分为新生代和老生代
比上面还多了个空间复制，一共5个GC算法

V8内存空间分为：
1 小空间用于存储新生代，存活时间较短的对象 16-32m


新生代对象的回收算法：复制算法和标记整理。
新生代内存区分为二个等大小空间，使用空间为from,空闲空间为To
标记整理后把活动对象拷贝至To,然后From和To交换空间完成释放
回收细节：
先标记区分活动对象和非活动对象，然后把活动对象拷贝到To空间，然后对From空间进行释放。
（经过一轮GC）在拷贝的过程中发现还有存活的活动对象，于是把它晋升到老生代对象 。
当To空间的使用率超过25%，那么把所有的新生代活动对象放到老生代中进行存放。

老生代对象的回收算法：1.4G   700M  标记清除，标记整理，增量标记。
哪些是老生代对象，全局作用域下的变量和闭包中的变量，可能会存活很长一段时间
细节：首先使用标记清除
当晋升时发现空间不够时，采用标记整理进行空间优化。
采用增量标记进行效率优化

比较：
新生代区域垃圾回收使用空间换时间
老生代区域垃圾回收不适合复制算法

7 内存问题
内存泄漏：内存使用持续升高
内存膨胀：在多数设备上都存在性能问题，拿各种测试机测试，看是机器有问题还是程序问题
频繁的垃圾回收：通过内存变化图进行分析

8 监控内存的几种方式
浏览器任务管理器
Timeline 时序图记录
堆快照查找分离DOM

分离DOM：脱离了DOM树，但是有程序在引用，那么这种DOM就叫做分离dom

9 判断是否存在频繁的垃圾回收
TimeLine中频繁的上升下降，任务管理器中的数据频繁的增加减小。
为什么要判断是否存在频繁的垃圾回收？
1 GC工作时应用程序是停止的
2 GC花的时间过长会导致应用假死
3 用户使用中感知应用卡顿

10 性能优化的几种方案
1 慎用全局变量，缓存全局变量到局部变量
2 通过prototype来添加附加方法，不通过class
3 在使用闭包的时候最后把闭包中的局部变量设置成null，有效防止内存泄漏
4 避免属性访问方法的使用
5 for循环中，i<arr.length时可以把这个length缓存到一个局部变量，提高性能
6 DOM操作消耗性能回流，重绘，

作业：

原理：引用关系改变时修改引用数字，当对象上的引用数为0时立即回收
优点：发现垃圾时立即回收，最大限度减少程序暂停，减少程序卡顿时间。
缺点：释放的空间可能不连续，导致空间碎片化，浪费空间，不会立即回收垃圾对象

1 先遍历对象找到所有可达对象，然后进行标记
2 移动对象位置，进行整理。
3 清除掉标记和所有未被标记的对象

3 新生代存储区垃圾回收
采用了复制算法和标记整理的方式，先遍历并标记可达对象，然后进行整理，整理完之后把from空间的可达对象复制到to空间，然后把from和to空间进行交换。

4 
在老生代存储区进行垃圾回收的时候使用到增量标记，原理是在程序运行的间隙间断地进行标记清除。








 
